<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Page fracturing on Intel CPUs | Nadav Amit</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Page fracturing on Intel CPUs" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Fighting Operating Systems" />
<meta property="og:description" content="Fighting Operating Systems" />
<link rel="canonical" href="http://localhost:4000/developed-posts/2018-10-21-page-fracturing.html" />
<meta property="og:url" content="http://localhost:4000/developed-posts/2018-10-21-page-fracturing.html" />
<meta property="og:site_name" content="Nadav Amit" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-01T14:52:01-07:00" />
<script type="application/ld+json">
{"description":"Fighting Operating Systems","@type":"BlogPosting","url":"http://localhost:4000/developed-posts/2018-10-21-page-fracturing.html","headline":"Page fracturing on Intel CPUs","dateModified":"2018-08-01T14:52:01-07:00","datePublished":"2018-08-01T14:52:01-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/developed-posts/2018-10-21-page-fracturing.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Nadav Amit" /></head>
<body><header class="site-header" role="banner">
   <div class="wrapper"><a class="site-title" rel="author" href="/">Nadav Amit</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

<div class="trigger">
  
   
  
    
  
    
  
    
  
    
  
    
  
    
    	<a class="page-link" href="/references.html">Publications</a>
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
    	<a class="page-link" href="/contact.html">Contact</a>
    
  
    
    	<a class="page-link" href="/about/">Service</a>
    
  
</div>

      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Page fracturing on Intel CPUs</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-08-01T14:52:01-07:00" itemprop="datePublished">Aug 1, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>During one of my studies, I encountered a strange phenomenon - it seemed as if every TLB flush in my virtual-machine, even a flush of a single page, caused a full TLB flush. Understanding this issue required some effort, and eventually was summarized in a single sentence in the academic paper I was working on. Since this micro-architectural behavior is not documented, it seemed appropriate to share the analysis in more detail. I break the story into background, investigation and conclusion sections. Feel free to skip directly to the latter, which describes this undocumented behavior.</p>

<h2 id="background">Background</h2>

<p>As we know, all modern CPUs use virtual memory, and CPUs translate virtual memory address into physical ones before they actually carry out the memory accesses. This translation is performed according to an architectural, memory-resident data-structure, which is set by the operating system, and maps virtual pages into physical frames. This data structure is a radix-tree, which also known as a page-table hierarchy in many architectures, including the x86 architecture, which is the subject of this discussion. Translating a virtual-address by “walking” a page-table hierarchy require multiple memory access, and since the CPU performs many memory accesses, it is essential to perform these translations fast.</p>

<p>For that matter CPUs hold a cache that holds the virtual-to-physical mappings, which is known as translation lookaside buffer or TLB. Unlike some other common caches, the TLB is not coherent, and when the operating system changes the mappings in memory, it is required to initiate a TLB flush operation to invalidate the caches. In the x86 architecture, two types of TLB flushes exist: a selective flush of a single page-table entry (PTE), which maps a single page, and a full flush that invalidates all the page-entries in the address-space<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>.</p>

<p>When hardware virtualization is used, the physical addresses of the (guest) virtual machine are not the same as the (host) machine physical address, since virtualization requires an additional level of memory indirection to allow the hypervisor to provision its physical memory among virtual machines. Modern CPUs perform the two levels of address translation in hardware: the guest virtual addresses (GVA) are translated into guest physical addresses (GPA) using the virtual-machine page tables, and the result GPA is then translated into host-physical address (HPA). This HPA is the address that would actually be used for the memory access. Again, to make these translation efficient, the TLB caches translations from GVA directly into HPA<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>.</p>

<h2 id="investigation">Investigation</h2>

<p>During my study it seemed that the TLB is fully flushed very frequently for no apparent reason. For brevity, I spare you the what led to think so. After some experiments, I started to suspect that invalidations of a single page (using the <code>invlpg</code> instruction) caused a full TLB flush instead. However, I had to ensure that the behavior I saw is not a result of cache evictions from the TLB or some unrelated operating system events. To confirm my suspicions I therefore needed a small, confined and controlled virtual-machine environment. <a href="https://www.linux-kvm.org/page/KVM-unit-tests">KVM-unit-tests</a>, which is an environment to create unit-tests that run inside virtual-machines and test that the KVM hypervisor behaves correctly, fitted these needs. Using this environment, I created a small test that measures the time it takes to perform memory accesses when occasionally a TLB flush is performed. I compared the time it takes to perform the accesses when the TLB flush is of a single page with the time it takes when a full TLB flush is performed. Note that the flush of the single page in the test was of a page that was <em>not</em> a part of the test working-set, and actually should not have been cached at all.</p>

<p>To perform a fair comparison, we need to take care of one additional point: a full TLB flush by itself (disregarding memory accesses) takes more time than a flush of a single page. I therefore subtracted the time it takes to perform the flushes for the comparison. The results on my Haswell machine confirmed my suspicions (results are formatted manually for readability, and some comments added):</p>

<table>
  <thead>
    <tr>
      <th>measurement</th>
      <th>cycles</th>
      <th>notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>with invlpg</td>
      <td>948,965,249</td>
      <td> </td>
    </tr>
    <tr>
      <td>with full flush</td>
      <td>1,047,927,009</td>
      <td> </td>
    </tr>
    <tr>
      <td>invlpg only</td>
      <td>127,682,028</td>
      <td> </td>
    </tr>
    <tr>
      <td>full flushes only</td>
      <td>224,055,273</td>
      <td> </td>
    </tr>
    <tr>
      <td>access net</td>
      <td>107,691,277</td>
      <td>considerably lower than the overhead of the flushes</td>
    </tr>
    <tr>
      <td>w/full flush net</td>
      <td>823,871,736</td>
      <td> </td>
    </tr>
    <tr>
      <td>w/invlpg net</td>
      <td>821,283,221</td>
      <td>almost identical to full-flush net</td>
    </tr>
  </tbody>
</table>

<p>As seen, the net time that memory accesses takes is almost identical when full TLB flushes are performed and when a single page is flushed. Performing the memory accesses by themselves (when no TLB flushes are initiated) is eight times lower, so the experienced behavior cannot be attributed to measurements errors.</p>

<p>What about AMD? Paolo Bonzini, the maintainer of KVM, was kind enough to run the same experiment on an AMD machine:</p>

<table>
  <thead>
    <tr>
      <th>measurement</th>
      <th>cycles</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>with invlpg</td>
      <td>285,639,427</td>
    </tr>
    <tr>
      <td>with full flush</td>
      <td>584,419,299</td>
    </tr>
    <tr>
      <td>invlpg only</td>
      <td>70,681,128</td>
    </tr>
    <tr>
      <td>full flushes only</td>
      <td>265,238,766</td>
    </tr>
    <tr>
      <td>access net</td>
      <td>242,538,804</td>
    </tr>
    <tr>
      <td>w/full flush net</td>
      <td>319,180,533</td>
    </tr>
    <tr>
      <td>w/invlpg net</td>
      <td>214,958,299</td>
    </tr>
  </tbody>
</table>

<p>AMD behavior is reasonable<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>. As the flushed page is not part of the working-set, the runtime of the test when no flushes take place (“access net”) and when a single page is flushed (“w/invlpg net”) are almost identical and faster by over 30% than the time it takes when full TLB flushes take place.</p>

<p>Does it always happen? Could it be that Intel missed such an issue, which does not affect correctness, but can hurt performance? Such a performance hit is not theoretical, but can have real performance impact on some common workloads, for example the Apache webserver, which frequently maps files to memory and then unmaps them, triggering TLB flushes. Further analysis was needed. Now that I confirmed the phenomenon is real, I could start to look on the performance-counters that measure TLB misses <sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>. After a few experiments, I realized that the behavior is indeed specific for virtual machines and depends on the page-sizes in the guest and host (nested) page tables. Here is a table that summarizes the number of dTLB misses, as reported by the performance counters, according to the different page-sizes:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Host page</th>
      <th>Guest page</th>
      <th>Full Flush</th>
      <th>Selective Flush</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>VM</td>
      <td>4KB</td>
      <td>4KB</td>
      <td>103,008,052</td>
      <td>93,172</td>
    </tr>
    <tr>
      <td> </td>
      <td>4KB</td>
      <td>2MB</td>
      <td>102,022,557</td>
      <td>102,038,021</td>
    </tr>
    <tr>
      <td> </td>
      <td>2MB</td>
      <td>4KB</td>
      <td>103,005,083</td>
      <td>2,888</td>
    </tr>
    <tr>
      <td> </td>
      <td>2MB</td>
      <td>2MB</td>
      <td>4,002,969</td>
      <td>2,556</td>
    </tr>
    <tr>
      <td>Bare-metal</td>
      <td>4KB</td>
      <td> </td>
      <td>50,000,572</td>
      <td>789</td>
    </tr>
    <tr>
      <td> </td>
      <td>2MB</td>
      <td> </td>
      <td>1,000,454</td>
      <td>537</td>
    </tr>
  </tbody>
</table>

<p>Ok, finally we understand that the problem only happens in then 2MB pages are used in virtual machines, which are mapped with 4KB pages in the nested page-tables. Note that this page sizes are not related to the size of the flushed pages: the flushed page was not even mapped in the page-tables so it could not have been cached in the TLB.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We got to the understanding that when a VM uses 2MB pages in its page-tables and the hypervisor uses 4KB pages in the nested page-tables, selective TLB cause full TLB flushes. But why? Through some private communication with Intel, I understood that this behavior is not a bug, but a feature that is intended to deal with what Intel calls “page fracturing”. What is page-fracturing? Let’s look at an excerpt of a virtual address space, as it is mapped in the guest and host page-table:</p>

<p><img src="/assets/fracturing-f5a34e2431ec3c6e2eb67f995f650c0a807f1a25f66bbaf3718025dc701a7fc9.png" alt="Fracturing" /></p>

<p>In such a scenario, the guest-virtual to host-physical address translation of each 4KB page will be held in a separate TLB entry. Obviously, some translations may be cached in the TLBs, while others - not. Let’s assume the mapping of A is cached and the one of B is not, and the OS directs the CPU to</p>

<p>guess they need to do it to follow the SDM 4.10.4.1 (regarding pages
larger than 4 KBytes):</p>

<blockquote>
  <p>The INVLPG instruction and page faults provide the same assurances that they provide when a single TLB entry is used: they invalidate all TLB entries corresponding to the translation specified by the paging structures.”</p>
</blockquote>

<p>Let’s assume that the OS directs the CPU to flush the mapping of the page A.</p>

<table>
  <tbody>
    <tr>
      <td>Guest page tables:</td>
      <td>2MB</td>
      <td>4KB</td>
    </tr>
  </tbody>
</table>

<pre><code>               +-----------------------------+-----+ Guest page tables: |             2MB             | 4KB |
               +-----+-----+-----+-----+-----+-----+---+ Host page tables:  | 4KB | 4KB | ... | 4KB | 4KB | 4KB |
               +-----+-----+-----+-----+-----+-----+
</code></pre>

<pre><code>		            A                       B
                            |                       |
                            v                       v
                   +-----------------------------+-----+
Guest page tables: |             2MB             | 4KB |
                   +-----+-----+-----+-----+-----+-----+---+
Host page tables:  | 4KB | 4KB | ... | 4KB | 4KB | 4KB |
                   +-----+-----+-----+-----+-----+-----+
</code></pre>

<p>I created a simple test that repeatedly accessed several (50) memory pages and then invalidated a completely different page:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span></span>    <span class="n">t_start</span> <span class="o">=</span> <span class="n">rdtsc</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ITERATIONS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">invlpg</span><span class="p">(</span><span class="n">another_addr</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N_PAGES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">t_single</span> <span class="o">=</span> <span class="n">rdtsc</span><span class="p">()</span> <span class="o">-</span> <span class="n">t_start</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;with invlpg:        %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">t_single</span><span class="p">);</span></code></pre></figure>

<p>To make sense of these resu
Then, I ran a similar test which performed a full TLB flush (by reloading the CR3 register) instead of the single page invalidation. Howeve</p>

<p>although it is not its intended use.</p>

<p>A verification was needed and for that matter I created a KVM unit-test - a small confined test which is no</p>

<p>address translation is done in two levels.   , the common and more efficient mode of</p>

<p>can be performed in granularity of either a single page
Many CPUs support multiple page sizes,</p>

<p>Several months ago, everybody was surprised to find out that the CPU speculative execution can be exploited to leak privileged information, using attacks that were named Spectre and Meltdown. Technical blogs and even the main-stream media reported broadly about those vulnerabilities. CPU vendors have struggled to provide firmware patches that would prevent the attacks in a timely manner. OS and other software providers introduced software solutions such as the <a href="https://software.intel.com/security-software-guidance/api-app/sites/default/files/Retpoline-A-Branch-Target-Injection-Mitigation.pdf">retpoline</a> and page table isolation (PTI) to protect against these vulnerabilities. All of these mitigations caused performance degradation, required extensive engineering effort, and caused various <a href="https://www.darkreading.com/risk/microsoft-issues-emergency-patch-to-disable-intels-broken-spectre-fix/d/d-id/1330932">problems</a>.</p>

<p>So half a year later - are you protected? Probably not. Recently I found that the Linux protection against Spectre v2 is broken in virtual machines and Dave Hansen found a bug in the <a href="https://www.darkreading.com/risk/microsoft-issues-emergency-patch-to-disable-intels-broken-spectre-fix/d/d-id/1330932">Meltdown</a> protection. Spectre v1 was never considered fully resolved, with mitigations keep coming in, but even the existing ones were found to be <a href="https://www.spinics.net/lists/linux-tip-commits/msg44433.html">buggy</a>.</p>

<p>There is clearly a problem, as currently it is hard for people to easily realize whether they are protected against these attacks. Sure, one can see whether the OS or other piece of software reports that it is protected, but these reports might be wrong. There is a fundamental problem with these protections that, in a way, is the same one that caused Linus Torvalds to politely (yes, politely) <a href="https://lkml.org/lkml/2018/2/15/1378">decline</a> a Meltdown mitigation technique we proposed<sup id="fnref:1:1"><a href="#fn:1" class="footnote">1</a></sup>:</p>

<blockquote>
  <p>Sure, I can see it working, but it’s some really shady stuff, and now the scheduler needs to save/restore/check one more subtle bit.</p>

  <p>And if you get it wrong, things will happily work, except you’ve now defeated PTI. But you’ll never notice, because you won’t be testing for it, and the only people who will are the black hats.</p>

  <p>This is exactly the “security depends on it being in sync” thing that makes me go “eww” about the whole model. Get one thing wrong, and you’ll blow all the PTI code out of the water.</p>
</blockquote>

<p>Linus criticism of our work is valid, yet it does not seem that other protection mechanisms against these vulnerabilities are much better. And even if the OS is well-protected against these vulnerabilities, nobody guarantees that the system will remain safe after an out-of-tree module is loaded, for example. All it takes for the Spectre v2 protection to be broken, for example, is a single indirect branch that was not converted into a retpoline.</p>

<p>It seems that in order to make the protection work, independent tools that validate the protection mechanisms are needed. I found the Spectre v2 by using the hardware performance counters to count indirect branches that were executed by the kernel and finding it is not zero. Dumping the page-tables and tracing translation-lookaside buffer (TLB) invalidations can be used to find out PTI bugs. Anti-malware tools should take up the glove and make these checks.</p>

<p>Yet, perhaps there is an additional problem of over-hyping Spectre. Side-channel attacks were known long before Spectre, and invoking them using speculative execution may not be such a game-changer. Unlike Meltdown, which is a real CPU bug, the Spectre family of vulnerabilities may pose lower risk as they are not easily exploitable. The Spectre v2 proof-of-concept exploited some Linux wrongdoings (e.g., not zeroing registers after a context switch from a virtual machine), which were relatively easily fixed and became a good mitigation against other OS bugs. Some new Spectre attacks were not even reported to be successfully exploitable other than in artificial <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1528">demos</a>.</p>

<p>It might be that the industry over-reacted to Spectre. Even if Spectre vulnerabilities are addressed, software might still leak privileged data through side-channels, so it is not as if the existing protection schemes are complete. Now that the media frenzy is gone, perhaps it is time to reconsider whether paying in performance for questionable “generic” protection schemes against these attacks makes sense, or whether protection should be done on a case-by-case basis.</p>

<p>Update: I wonder if Windows is indeed safe. Windows uses retpoline, but it is not clear whether they are used exclusively or with alternative solutions that use hardware mitigation (IBPB/IBRS). Anyhow, measuring the performance counter of Windows 10 (that runs in the VM) raises some questions, as it show there are indirect branches inside Windows kernel. Here are the performance counters as measure in a KVM guest:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span></span>$ sudo perf stat -e br_inst_exec.taken_indirect_jump_non_call_ret:Gk <span class="se">\</span>
  -e br_inst_exec.taken_indirect_near_call:Gk -a -- sleep <span class="m">5</span>
 
 Performance counter stats <span class="k">for</span> <span class="s1">&#39;system wide&#39;</span>:

         <span class="m">1</span>,682,939      br_inst_exec.taken_indirect_jump_non_call_ret:Gk
         <span class="m">1</span>,102,037      br_inst_exec.taken_indirect_near_call:Gk

       <span class="m">5</span>.001077704 seconds <span class="nb">time</span> elapsed</code></pre></figure>

<h2 id="footnotes">Footnotes</h2>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Ignoring INVPCID flavors and global page flushes for simplicity <a href="#fnref:1" class="reversefootnote">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2">
      <p>There are additional schemes <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>The results show as if memory accesses are faster when TLB flushes of a single page are performed then when no TLB flushes take place. This does not make much sense. This result appears to be an artifact of the test measurement scheme, which disregards out-of-order execution behavior. The tests were only intended to provide qualitative indication whether full TLB flushes take place. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Usually, I try to avoid relying on such counters as the sole indication for hardware behavior, as it is known that some of them are can provide incorrect results in certain cases. <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div><a class="u-url" href="/developed-posts/2018-10-21-page-fracturing.html" hidden></a>
</article>

      </div>
    </main><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-18361927-3"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-18361927-3');
</script>

</body>

</html>
